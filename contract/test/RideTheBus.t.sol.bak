// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {RideTheBus} from "../RideTheBus.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {VRFCoordinatorV2_5Mock} from "chainlink/contracts/src/v0.8/vrf/mocks/VRFCoordinatorV2_5Mock.sol";

contract TT is ERC20("TT","TT") { constructor(){_mint(msg.sender,1e24);} }

contract RideTheBusLeanTest is Test {
    TT token; VRFCoordinatorV2_5Mock coord; RideTheBus game; uint256 subId;
    address player = address(0xBEEF);

    function setUp() public {
        token = new TT();
        coord = new VRFCoordinatorV2_5Mock(0.1 ether, 1e9);
        subId = coord.createSubscription(); coord.fundSubscription(subId, 10 ether);
        bytes32 keyHash = bytes32(uint256(1));
        game = new RideTheBus(address(0xF0), IERC20(address(token)), address(coord), keyHash, subId, 1_000_000 ether);
        coord.addConsumer(subId, address(game));
        token.transfer(address(game), 1_000_000 ether);
        token.transfer(player, 1_000 ether);
        vm.prank(player); token.approve(address(game), type(uint256).max);
    }

    function _fulfill(uint256 rid) internal { uint256[] memory w=new uint256[](2); w[0]=123; w[1]=456; coord.fulfillRandomWords(rid, address(game), w); }

    function test_Flow_PlaySome_CashOut() public {
        vm.prank(player); uint256 gid = game.startGame(100 ether, 3600);
        _fulfill(1);
        // Round 0: red(0)
        vm.prank(player); game.playRound(gid, abi.encodePacked(uint8(0)));
        // Round 1: higher(1)
        vm.prank(player); game.playRound(gid, abi.encodePacked(uint8(1)));
        // Cash out
        uint256 b0 = token.balanceOf(player);
        vm.prank(player); game.cashOut(gid);
        uint256 b1 = token.balanceOf(player);
        assertGt(b1, b0);
    }
}
